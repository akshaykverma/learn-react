# Redux & State Management Complete Guide

## ðŸ“š Table of Contents
1. [Redux Fundamentals](#redux-fundamentals)
2. [Redux Toolkit (RTK)](#redux-toolkit-rtk)
3. [RTK Query](#rtk-query)
4. [State Management Patterns](#state-management-patterns)
5. [Hooks & Selectors](#hooks--selectors)
6. [Entity Adapter](#entity-adapter)
7. [Async Operations](#async-operations)
8. [Performance Optimization](#performance-optimization)

---

## ðŸ”„ Redux Fundamentals

### What is Redux?
Redux is a predictable state container for JavaScript apps. It helps you manage application state in a centralized, predictable way.

### Core Principles
1. **Single Source of Truth** - One store for entire app state
2. **State is Read-Only** - Only way to change state is by dispatching actions
3. **Changes Made with Pure Functions** - Reducers specify how state changes

### Redux Data Flow
```
Action â†’ Reducer â†’ Store â†’ Component â†’ Action (cycle continues)
```

---

## ðŸ› ï¸ Redux Toolkit (RTK)

### Why Redux Toolkit?
Traditional Redux requires lots of boilerplate. RTK simplifies Redux usage with:
- Less boilerplate code
- Built-in best practices
- Immutable updates with Immer
- DevTools integration

### Store Configuration
**File**: `src/store/store.js`
```javascript
import { configureStore } from '@reduxjs/toolkit'
import usersReducer from '../features/users/usersSlice'
import { apiSlice } from '../features/api/apiSlice'

export const store = configureStore({
    reducer: {
        [apiSlice.reducerPath]: apiSlice.reducer, // RTK Query reducer
        users: usersReducer                       // Traditional slice reducer
    },
    middleware: getDefaultMiddleware => 
        getDefaultMiddleware().concat(apiSlice.middleware), // RTK Query middleware
    devTools: true // Enable Redux DevTools
})
```

**Key Concepts**:
- **configureStore**: Replaces legacy `createStore` with better defaults
- **Reducer Combination**: Multiple reducers combined into one root reducer
- **Middleware**: Functions that intercept actions before they reach reducers
- **DevTools**: Browser extension for debugging Redux state

---

## ðŸ° Slices

### What is a Slice?
A slice is a collection of Redux reducer logic and actions for a single feature.

### Traditional Slice Example
**File**: `src/features/users/usersSlice.js`
```javascript
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit"

// Async action creator
export const fetchUsers = createAsyncThunk(
    'users/fetchUsers', // Action type prefix
    async () => {
        const response = await axios.get(USERS_URL)
        return response.data // This becomes action.payload
    }
)

const usersSlice = createSlice({
    name: 'users',           // Slice name
    initialState: [],        // Initial state value
    reducers: {              // Synchronous reducers
        // No sync actions needed for users
    },
    extraReducers(builder) { // Async reducers
        builder.addCase(fetchUsers.fulfilled, (state, action) => {
            return action.payload // Replace entire state with fetched users
        })
    }
})

export default usersSlice.reducer
```

**Key Concepts**:
- **createSlice**: Generates action creators and reducers automatically
- **initialState**: Starting value for this slice of state
- **reducers**: Synchronous state updates
- **extraReducers**: Handle actions from other slices or async thunks
- **Immer Integration**: Write "mutative" logic that's actually immutable

### State Structure After Users Load
```javascript
// Redux State
{
    users: [
        { id: 1, name: "John Doe", email: "john@example.com" },
        { id: 2, name: "Jane Smith", email: "jane@example.com" }
    ],
    api: { /* RTK Query state */ }
}
```

---

## ðŸ” Actions

### What are Actions?
Actions are plain JavaScript objects that describe what happened. They must have a `type` property.

### Action Examples from Our App
```javascript
// Automatically generated by createSlice
{
    type: 'users/fetchUsers/fulfilled',
    payload: [
        { id: 1, name: "John Doe" },
        { id: 2, name: "Jane Smith" }
    ]
}

// RTK Query generated action
{
    type: 'api/executeQuery/fulfilled',
    payload: { /* posts data */ },
    meta: { /* query metadata */ }
}
```

### Action Creators
```javascript
// Traditional way (verbose)
const addUser = (user) => ({
    type: 'users/addUser',
    payload: user
})

// RTK way (automatic)
const usersSlice = createSlice({
    name: 'users',
    reducers: {
        addUser: (state, action) => {
            state.push(action.payload) // Immer makes this immutable
        }
    }
})
export const { addUser } = usersSlice.actions // Auto-generated action creator
```

---

## ðŸ”„ Reducers

### What are Reducers?
Pure functions that take current state and an action, return new state.

### Reducer Rules
1. **Pure Functions** - Same input always produces same output
2. **No Side Effects** - No API calls, no mutations
3. **Immutable Updates** - Return new state object

### Reducer Example
```javascript
// Traditional reducer (verbose)
function usersReducer(state = [], action) {
    switch (action.type) {
        case 'users/fetchUsers/fulfilled':
            return action.payload
        case 'users/addUser':
            return [...state, action.payload]
        default:
            return state
    }
}

// RTK slice reducer (concise)
const usersSlice = createSlice({
    name: 'users',
    initialState: [],
    reducers: {
        addUser: (state, action) => {
            state.push(action.payload) // Looks like mutation, but Immer makes it immutable
        }
    },
    extraReducers: (builder) => {
        builder.addCase(fetchUsers.fulfilled, (state, action) => {
            return action.payload // Replace entire state
        })
    }
})
```

---

## ðŸŒ RTK Query

### What is RTK Query?
Data fetching and caching solution built on top of Redux Toolkit. Eliminates need to write data fetching logic manually.

### Base API Slice
**File**: `src/features/api/apiSlice.js`
```javascript
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const apiSlice = createApi({
    reducerPath: 'api',    // State key where this API's data is stored
    baseQuery: fetchBaseQuery({ 
        baseUrl: 'http://localhost:3500' 
    }),
    tagTypes: ['Post', 'User'], // Cache invalidation tags
    endpoints: builder => ({})   // Extended by other slices
})
```

### Extended API Slice
**File**: `src/features/posts/postsSlice.js`
```javascript
export const extendedApiSlice = apiSlice.injectEndpoints({
    endpoints: builder => ({
        // QUERY - for reading data
        getPosts: builder.query({
            query: () => '/posts',
            transformResponse: responseData => {
                // Transform and normalize data
                const loadedPosts = responseData.map(post => ({
                    ...post,
                    date: post.date || new Date().toISOString(),
                    reactions: post.reactions || {
                        thumbsUp: 0, wow: 0, heart: 0, rocket: 0, coffee: 0
                    }
                }))
                return postsAdapter.setAll(initialState, loadedPosts)
            },
            providesTags: (result, error, arg) => [
                { type: 'Post', id: 'LIST' },
                ...result.ids.map(id => ({ type: 'Post', id }))
            ]
        }),

        // MUTATION - for creating/updating/deleting data
        addNewPost: builder.mutation({
            query: initialPost => ({
                url: '/posts',
                method: 'POST',
                body: {
                    ...initialPost,
                    id: nanoid(),
                    date: new Date().toISOString(),
                    reactions: { thumbsUp: 0, wow: 0, heart: 0, rocket: 0, coffee: 0 }
                }
            }),
            invalidatesTags: [{ type: 'Post', id: 'LIST' }] // Refetch posts list
        })
    })
})

// Auto-generated hooks
export const { 
    useGetPostsQuery, 
    useAddNewPostMutation 
} = extendedApiSlice
```

### RTK Query Benefits
1. **Automatic Caching** - Prevents duplicate requests
2. **Background Refetching** - Keeps data fresh
3. **Cache Invalidation** - Smart cache updates
4. **Loading States** - Built-in loading/error states
5. **Optimistic Updates** - Immediate UI feedback

---

## ðŸŽ£ Hooks & Selectors

### RTK Query Hooks
Generated automatically from API endpoints:

```javascript
// In component
function PostsList() {
    // Query hook - for reading data
    const {
        data,           // The actual data
        isLoading,      // Loading state
        isSuccess,      // Success state
        isError,        // Error state
        error,          // Error object
        refetch         // Manual refetch function
    } = useGetPostsQuery()

    // Mutation hook - for modifying data
    const [addNewPost, { 
        isLoading: isAdding,
        isSuccess: isAddSuccess 
    }] = useAddNewPostMutation()

    const handleAddPost = async (postData) => {
        try {
            await addNewPost(postData).unwrap() // unwrap for error handling
        } catch (error) {
            console.error('Failed to add post:', error)
        }
    }
}
```

### Redux Selectors
Functions that extract specific pieces of state:

```javascript
// Basic selector
export const selectAllUsers = (state) => state.users

// Parameterized selector
export const selectUserById = (state, userId) =>
    state.users.find(user => user.id === userId)

// Memoized selector (performance optimization)
import { createSelector } from '@reduxjs/toolkit'

export const selectPostsData = createSelector(
    selectPostsResult,
    postsResult => postsResult.data // Only recalculates if postsResult changes
)
```

### Using Selectors in Components
```javascript
import { useSelector } from 'react-redux'
import { selectAllUsers, selectUserById } from '../features/users/usersSlice'

function UserComponent({ userId }) {
    // Select all users
    const users = useSelector(selectAllUsers)
    
    // Select specific user
    const user = useSelector(state => selectUserById(state, userId))
    
    return <div>{user?.name}</div>
}
```

---

## ðŸ“Š Entity Adapter

### What is Entity Adapter?
Utility for managing normalized state structure. Provides CRUD operations and selectors.

### Why Normalize State?
```javascript
// Non-normalized (inefficient for updates)
{
    posts: [
        { id: 1, title: "Post 1", author: { id: 1, name: "John" } },
        { id: 2, title: "Post 2", author: { id: 1, name: "John" } }
    ]
}
// Problem: Updating John's name requires finding all posts by John

// Normalized (efficient)
{
    posts: {
        ids: [1, 2],
        entities: {
            1: { id: 1, title: "Post 1", authorId: 1 },
            2: { id: 2, title: "Post 2", authorId: 1 }
        }
    },
    users: {
        ids: [1],
        entities: {
            1: { id: 1, name: "John" }
        }
    }
}
// Solution: Update user once, all references automatically updated
```

### Entity Adapter Setup
```javascript
import { createEntityAdapter } from '@reduxjs/toolkit'

const postsAdapter = createEntityAdapter({
    // Optional: custom sorting
    sortComparer: (a, b) => b.date.localeCompare(a.date)
})

const initialState = postsAdapter.getInitialState()
// Returns: { ids: [], entities: {} }
```

### Entity Adapter Methods
```javascript
// In RTK Query transformResponse
transformResponse: responseData => {
    const loadedPosts = responseData.map(post => ({ ...post, /* normalize */ }))
    
    // Entity adapter methods
    return postsAdapter.setAll(initialState, loadedPosts)     // Replace all
    // postsAdapter.addOne(state, newPost)                    // Add single
    // postsAdapter.addMany(state, newPosts)                  // Add multiple
    // postsAdapter.updateOne(state, { id, changes })         // Update single
    // postsAdapter.removeOne(state, id)                      // Remove single
}
```

### Auto-Generated Selectors
```javascript
// Entity adapter creates these selectors automatically
export const {
    selectAll: selectAllPosts,        // Get all posts as array
    selectById: selectPostById,       // Get post by ID
    selectIds: selectPostIds,         // Get all IDs as array
    selectEntities: selectPostEntities, // Get entities object
    selectTotal: selectPostsTotal     // Get total count
} = postsAdapter.getSelectors(state => selectPostsData(state) ?? initialState)

// Usage in components
function PostsList() {
    const postIds = useSelector(selectPostIds)        // [1, 2, 3]
    const allPosts = useSelector(selectAllPosts)      // [post1, post2, post3]
    const post1 = useSelector(state => selectPostById(state, 1)) // post1 object
}
```

---

## âš¡ Async Operations

### Async Thunks
For complex async logic that doesn't fit RTK Query:

```javascript
import { createAsyncThunk } from '@reduxjs/toolkit'

// Async thunk action creator
export const fetchUsers = createAsyncThunk(
    'users/fetchUsers',           // Action type prefix
    async (arg, { getState, dispatch, rejectWithValue }) => {
        try {
            const response = await axios.get(USERS_URL)
            return response.data      // Becomes fulfilled action payload
        } catch (error) {
            return rejectWithValue(error.message) // Becomes rejected action payload
        }
    }
)

// Handling in slice
const usersSlice = createSlice({
    name: 'users',
    initialState: { users: [], loading: false, error: null },
    extraReducers: (builder) => {
        builder
            .addCase(fetchUsers.pending, (state) => {
                state.loading = true
                state.error = null
            })
            .addCase(fetchUsers.fulfilled, (state, action) => {
                state.loading = false
                state.users = action.payload
            })
            .addCase(fetchUsers.rejected, (state, action) => {
                state.loading = false
                state.error = action.payload
            })
    }
})
```

### RTK Query vs Async Thunks

| Feature | RTK Query | Async Thunks |
|---------|-----------|--------------|
| **Use Case** | API calls, caching | Complex async logic |
| **Caching** | Automatic | Manual |
| **Loading States** | Built-in | Manual |
| **Error Handling** | Built-in | Manual |
| **Cache Invalidation** | Automatic | Manual |
| **Background Refetch** | Built-in | Manual |

---

## ðŸš€ Performance Optimization

### Memoized Selectors
```javascript
import { createSelector } from '@reduxjs/toolkit'

// Expensive computation only runs when dependencies change
const selectExpensiveData = createSelector(
    [selectAllPosts, selectAllUsers], // Dependencies
    (posts, users) => {
        // Expensive computation here
        return posts.map(post => ({
            ...post,
            author: users.find(user => user.id === post.userId)
        }))
    }
)
```

### Component Optimization
```javascript
// âŒ Bad: Re-renders on any state change
function PostsList() {
    const state = useSelector(state => state)
    return state.posts.map(post => <PostCard key={post.id} post={post} />)
}

// âœ… Good: Only re-renders when posts change
function PostsList() {
    const postIds = useSelector(selectPostIds)
    return postIds.map(postId => <PostCard key={postId} postId={postId} />)
}

// âœ… Good: Each card only re-renders when its specific post changes
function PostCard({ postId }) {
    const post = useSelector(state => selectPostById(state, postId))
    return <div>{post.title}</div>
}
```

### RTK Query Cache Optimization
```javascript
// Cache configuration
getPosts: builder.query({
    query: () => '/posts',
    keepUnusedDataFor: 60,        // Keep cache for 60 seconds after last use
    refetchOnMountOrArgChange: 30, // Refetch if data is older than 30 seconds
    refetchOnFocus: true,         // Refetch when window regains focus
    refetchOnReconnect: true      // Refetch when network reconnects
})
```

---

## ðŸ”„ Advanced Patterns

### Optimistic Updates
```javascript
addReaction: builder.mutation({
    query: ({ postId, reactions }) => ({
        url: `posts/${postId}`,
        method: 'PATCH',
        body: { reactions }
    }),
    async onQueryStarted({ postId, reactions }, { dispatch, queryFulfilled }) {
        // 1. Update cache immediately (optimistic)
        const patchResult = dispatch(
            extendedApiSlice.util.updateQueryData('getPosts', undefined, draft => {
                const post = draft.entities[postId]
                if (post) post.reactions = reactions
            })
        )
        
        try {
            // 2. Wait for server response
            await queryFulfilled
            // 3. If successful, keep the optimistic update
        } catch {
            // 4. If failed, rollback the optimistic update
            patchResult.undo()
        }
    }
})
```

### Cache Invalidation Strategies
```javascript
// Strategy 1: Invalidate entire list
addNewPost: builder.mutation({
    invalidatesTags: [{ type: 'Post', id: 'LIST' }]
})

// Strategy 2: Invalidate specific item
updatePost: builder.mutation({
    invalidatesTags: (result, error, arg) => [{ type: 'Post', id: arg.id }]
})

// Strategy 3: Conditional invalidation
deletePost: builder.mutation({
    invalidatesTags: (result, error, arg) => 
        result ? [{ type: 'Post', id: arg.id }, { type: 'Post', id: 'LIST' }] : []
})
```

### Manual Cache Updates
```javascript
// Instead of invalidating, manually update cache
const [updatePost] = useUpdatePostMutation()

const handleUpdate = async (updatedPost) => {
    try {
        await updatePost(updatedPost).unwrap()
        
        // Manually update cache without refetch
        dispatch(
            extendedApiSlice.util.updateQueryData('getPosts', undefined, draft => {
                const existingPost = draft.entities[updatedPost.id]
                if (existingPost) {
                    Object.assign(existingPost, updatedPost)
                }
            })
        )
    } catch (error) {
        console.error('Update failed:', error)
    }
}
```

---

## ðŸŽ¯ Best Practices Summary

### State Structure
- âœ… Keep state normalized with Entity Adapter
- âœ… Separate server state (RTK Query) from client state (slices)
- âœ… Use meaningful slice names
- âŒ Don't store derived data in state

### Selectors
- âœ… Use memoized selectors for expensive computations
- âœ… Keep selectors simple and focused
- âœ… Co-locate selectors with their slices
- âŒ Don't select entire state object

### Components
- âœ… Select minimal data needed
- âœ… Use specific selectors over generic ones
- âœ… Handle loading and error states
- âŒ Don't dispatch actions in render

### Performance
- âœ… Use RTK Query for server state
- âœ… Implement optimistic updates for better UX
- âœ… Configure appropriate cache times
- âŒ Don't over-invalidate cache

---

## ðŸ“– Quick Reference

### Common Hooks
```javascript
// RTK Query
const { data, isLoading, error } = useGetPostsQuery()
const [addPost, { isLoading }] = useAddNewPostMutation()

// Redux
const posts = useSelector(selectAllPosts)
const dispatch = useDispatch()

// React Router
const navigate = useNavigate()
const { postId } = useParams()
```

### Common Patterns
```javascript
// Async operation with error handling
const handleSubmit = async (data) => {
    try {
        await addNewPost(data).unwrap()
        navigate('/')
    } catch (error) {
        console.error('Failed:', error)
    }
}

// Conditional rendering with loading states
if (isLoading) return <div>Loading...</div>
if (error) return <div>Error: {error.message}</div>
return <div>{data}</div>
```

This guide covers all the Redux and state management concepts used in your application with practical examples from your actual code. Use it as a reference to understand how modern Redux patterns work together to create efficient, maintainable applications.